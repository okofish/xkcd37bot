// Generated by CoffeeScript 1.7.1
var BACKTRACK_POLL_INTERVAL, LIMIT, MAX_ATTEMPTS, POLL_INTERVAL, RedditStream, events, get_items_backtrack_timeout_id, get_items_timeout_id, q, rawjs, reddit,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

q = require('q');

rawjs = require('raw.js');

events = require('events');

reddit = new rawjs();

get_items_timeout_id = null;

get_items_backtrack_timeout_id = null;

LIMIT = 100;

MAX_ATTEMPTS = 5;

POLL_INTERVAL = 5000;

BACKTRACK_POLL_INTERVAL = 2000;

module.exports = RedditStream = (function(_super) {
  __extends(RedditStream, _super);

  RedditStream.prototype.is_running = false;

  function RedditStream(type, subreddit, user_agent, auth) {
    this.type = type;
    this.subreddit = subreddit != null ? subreddit : 'all';
    if (user_agent == null) {
      user_agent = 'reddit-stream bot';
    }
    if (auth == null) {
      auth = null;
    }
    this.getItems = __bind(this.getItems, this);
    if (!(this.type === 'posts' || this.type === 'comments')) {
      throw new Error('type must be "posts" or "comments"');
    }
    reddit._userAgent = user_agent;
    if (auth != null) {
      this.login(auth);
    }
  }

  RedditStream.prototype.login = function(auth) {
    var deferred, _ref, _ref1;
    if (!((((_ref = auth.app) != null ? _ref.id : void 0) != null) && (((_ref1 = auth.app) != null ? _ref1.secret : void 0) != null) && (auth.username != null) && (auth.password != null))) {
      throw new Error('auth object must have app.id, app.secret, username, and password');
    }
    deferred = q.defer();
    reddit.setupOAuth2(auth.app.id, auth.app.secret);
    reddit.auth({
      username: auth.username,
      password: auth.password
    }, (function(_this) {
      return function(error, response) {
        if (error != null) {
          deferred.reject(error);
          return _this.emit('login.error', error);
        } else {
          deferred.resolve(response);
          return _this.emit('login.success', response);
        }
      };
    })(this));
    return deferred.promise;
  };

  RedditStream.prototype.start = function() {
    this.is_running = true;
    this.getItems();
    return this.emit('start');
  };

  RedditStream.prototype.stop = function() {
    this.is_running = false;
    clearTimeout(get_items_timeout_id);
    clearTimeout(get_items_backtrack_timeout_id);
    return this.emit('stop');
  };

  RedditStream.prototype.getItems = function(newest, last_newest, after, attempt, is_backtracking) {
    var callback, options;
    if (newest == null) {
      newest = '';
    }
    if (last_newest == null) {
      last_newest = '';
    }
    if (after == null) {
      after = '';
    }
    if (attempt == null) {
      attempt = 1;
    }
    if (is_backtracking == null) {
      is_backtracking = false;
    }
    if (!this.is_running) {
      return;
    }
    options = {
      r: this.subreddit,
      limit: LIMIT,
      after: after !== '' ? after : void 0
    };
    callback = (function(_this) {
      return function(error, response) {
        var item, items, new_items, should_backtrack, _i, _len, _ref, _ref1;
        if (!_this.is_running) {
          return;
        }
        if (_this.type === 'posts') {
          items = response != null ? response.children : void 0;
        } else if (_this.type === 'comments') {
          items = response != null ? (_ref = response.data) != null ? _ref.children : void 0 : void 0;
        }
        if ((error != null) || (items == null)) {
          if (error != null) {
            _this.emit('error', {
              message: 'could not get items (error)',
              response: response,
              error: error
            });
          } else {
            _this.emit('error', {
              message: 'could not get items (empty response):',
              response: response,
              error: error
            });
          }
          if (++attempt <= MAX_ATTEMPTS) {
            return get_items_timeout_id = setTimeout((function() {
              return _this.getItems(newest, last_newest, after, attempt, is_backtracking);
            }), POLL_INTERVAL);
          } else if (!is_backtracking) {
            return get_items_timeout_id = setTimeout(_this.getItems, POLL_INTERVAL);
          }
        } else {
          new_items = [];
          if (items.length > 0) {
            for (_i = 0, _len = items.length; _i < _len; _i++) {
              item = items[_i];
              if (is_backtracking) {
                if (item.data.name <= last_newest) {
                  break;
                }
              } else {
                if (item.data.name <= newest) {
                  break;
                }
              }
              new_items.push(item);
            }
            if (items[0].data.name > newest && !is_backtracking) {
              last_newest = newest;
              newest = items[0].data.name;
            }
            after = items[items.length - 1].data.name;
          }
          if (new_items.length > 0) {
            _this.emit('new', new_items);
          }
          should_backtrack = new_items.length === items.length;
          if (last_newest === '' || ((0 <= (_ref1 = items.length) && _ref1 < LIMIT))) {
            should_backtrack = false;
          }
          if (is_backtracking) {
            if (should_backtrack) {
              return get_items_backtrack_timeout_id = setTimeout((function() {
                return _this.getItems(newest, last_newest, after, 1, true);
              }), BACKTRACK_POLL_INTERVAL);
            }
          } else {
            if (should_backtrack) {
              get_items_backtrack_timeout_id = setTimeout((function() {
                return _this.getItems(newest, last_newest, after, 1, true);
              }), 0);
            }
            return get_items_timeout_id = setTimeout((function() {
              return _this.getItems(newest, last_newest);
            }), POLL_INTERVAL);
          }
        }
      };
    })(this);
    if (this.type === 'posts') {
      return reddit["new"](options, callback);
    } else if (this.type === 'comments') {
      return reddit.comments(options, callback);
    }
  };

  return RedditStream;

})(events.EventEmitter);
